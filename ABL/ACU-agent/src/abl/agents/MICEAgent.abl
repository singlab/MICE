package abl.generated;
// the package corresponds to where generated Java files are placed.

import abl.wmes.*;
import abl.actions.*;
import abl.sensors.*;
import java.lang.*;
// Imports are used the same way as in Java. Its necessary to import Sensor, Action, and WME classes.
/** 
 * A simple agent that moves towards the player and occassionally fires bullets.
 *
 * @author Josh McCoy 1-23-2019
 * @author Ben Weber 3-7-11
 */ 
behaving_entity MICEAgent {
// This defines a name for the agent 

	/** 
	 * Define the physicals actions that the agent can perform. The definition includes an action prototype and
	 * and an action class name. The class name must be a Java class which has been imported. 
	 *
	 * The prototype parameters correspond to the types expected by the execute(object[]) method 
	 * in the action's Java class.
	 */
	register act stop(int) with Stop;
	register act testAction(String) with TestAction;

	/**
	 * Define the sensors that add game state to working memory. Each sensor defines the name of the WME class
	 * that it is responsible for managing and the Java sensor class that implements the functionality. 
	 */
    register wme TestWME with TestSensor;

	/**
	 * Defines a variable scope to the agent, which can be used and modified in behaviors. 
	 *
	 * It is also possible to use constants from a Java interface (e.g.):
     * constants game.Constants;   
	 */ 	
    
    sequential behavior MICERoot() {
		with (persistent) subgoal MICENode();
	}
    // Ideally this is a generic mice node that works with 
    // any of the four mice elements.
    //TODO: Add in enum support for the MICE elements, since that makes the
    // most sense
    sequential behavior MICENode() {
		precondition {
			(TestWME test=="")
		}
		subgoal startThread();
		with (ignore_failue) subgoal MICENode();
		subgoal endThread();
	}
    // TODO: Bind the type, then pass it through the substeps.
	sequential behavior startThread() {
		precondition { (TestWME test::test) }
	    mental_act { 
	    	System.out.println("STARTING THREAD.");
	    }
		act testAction(test);
	}
	sequential behavior endThread() {
	    mental_act { 
	    	System.out.println("ENDING THREAD.");
	    }
	}
    
    
    
	sequential behavior MICENode() {
		precondition {
			(TestWME test=="milieu")
		}
		subgoal startMilieuThread();
		subgoal MICENode();
		subgoal endMilieuThread();
	}
	sequential behavior MICENode() {
		precondition {
			(TestWME test=="inquiry")
		}
		subgoal startInquiryThread();
		subgoal MICENode();
		subgoal endInquiryThread();
	}
	sequential behavior MICENode() {
		precondition {
			(TestWME test=="character")
		}
		subgoal startCharacterThread();
		subgoal MICENode();
		subgoal endCharacterThread();
	}
	sequential behavior MICENode() {
		precondition {
			(TestWME test=="event")
		}
		sequential {
			subgoal startEventThread();
			with (ignore_failure) subgoal MICENode();
			subgoal endEventThread();			
		}
	}
	
	sequential behavior startMilieuThread() {
		precondition { (TestWME test::test) }
	    mental_act { 
	    	System.out.println("STARTING MILIEU.");
	    }
		act testAction(test);
	}
	sequential behavior endMilieuThread() {
	    mental_act { 
	    	System.out.println("ENDING MILIEU.");
	    }
	}
	
	sequential behavior startInquiryThread() {
		precondition { (TestWME test::test) }
	    mental_act { 
	    	System.out.println("STARTING INQUIRY.");
	    }
		act testAction(test);
	}
	sequential behavior endInquiryThread() {
	    mental_act { 
	    	System.out.println("ENDING INQUIRY.");
	    }
	}

	sequential behavior startCharacterThread() {
		precondition { (TestWME test::test) }
	    mental_act { 
	    	System.out.println("STARTING CHARACTER.");
	    }
		act testAction(test);
	}
	sequential behavior endCharacterThread() {
	    mental_act { 
	    	System.out.println("ENDING INQUIRY.");
	    }
	}
	
	sequential behavior startEventThread() {
	    mental_act { 
	    	System.out.println("STARTING EVENT.");
	    }
		act testAction("We are finally here");
	}
	sequential behavior endEventThread() {
		precondition { (TestWME test::test) }
	    mental_act { 
	    	System.out.println("ENDING EVENT.");
	    }
	    act testAction(test);
	}

    /**
     * Utility behavior for suspending the execution of a behavior.
     *
     * This behavior consist of two steps. First, the mental act compute the finishing time
     * based on the input delay. Second, the success tests waits until the condition check
     * evaluates to true.
     */
	sequential behavior Wait(int milliseconds) {
		long finish;
	    mental_act { 
	    	finish = System.currentTimeMillis() + milliseconds; 
	    }
	    
	    with ( success_test { (System.currentTimeMillis() > finish) } ) wait;
	}
	/**
	 * TODO: This code is really poor quality. It should be a success_test
	 * as described within the ABL documentation to ensure an
	 * event-driven response rather than this delaying polling that we are doing.
	 * Also figure out how to have this test only fire once per event.
	 * (Probably going to need the success_test to add back test_behavior to the 
	 * ABT after the action occurs.
	 */
	sequential behavior testBehavior() {
		precondition {
			(TestWME test::test)
		}
		act testAction(test);
		subgoal Wait(1000);
		with (persistent) subgoal testBehavior();
	}
 
    /** 
     * Root of the active behavior tree.
     *
     * Note: this is a parallel behavior.
     * Note: the ABL compiler expects this to be the last behavior defined in the agent. 
     * Note: prioirities are used to ensure all goals are pursued, since the move() goal can thrash in this simple example
     */
    initial_tree {
    	with (priority 3) mental_act {
			System.out.println("Starting bot Agent");
    	}
    	with (priority 2) subgoal MICERoot();
    }
}
